\documentclass[paper=a4, fontsize=11pt]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage[ngerman,english]{babel}
\usepackage{hyperref}
\usepackage{wrapfig}
\usepackage{minted}
\usepackage{multicol}
\usepackage{color}
\usepackage{pifont}
\usepackage{tikz}
\usepackage{amsmath}

\title{Autonomous Parking Scenario}
\author{Alexander Reisner \href{mailto:alexander.reisner@tum.de}{\texttt{alexander.reisner@tum.de}} \and
Alexander Weidinger \href{mailto:alexander.weidinger@tum.de}{\texttt{alexander.weidinger@tum.de}} \and
David Werner \href{mailto:david.werner@tum.de}{\texttt{david.werner@tum.de}}}
\date{\today}

\begin{document}

% title page
\maketitle
\newpage

% toc
\tableofcontents
\newpage

\section{General}
\begin{itemize}
  \item Task description
  \item Overview diagram
  \item Dataflow diagram (sequence diagram?)
\end{itemize}
\section{SpeedDreams 2}
\begin{itemize}
  \item What is SpeedDreams 2?
  \item Why do we need SpeedDreams 2?
  \item What changes do we need to make?
\end{itemize}
\subsection{Proximity Sensor}
\begin{itemize}
  \item Related work (Sensor by the Simulated Car Racing Championship, ...)
  \item Idea and approach
  \item Implementation details and problems (+ solutions)
\end{itemize}
\subsection{Starting Grid}
\begin{itemize}
  \item We need it to get reproducible results each run
  \item Idea and approach
  \item Implementation details
\end{itemize}
\subsection{Driving bots}
\subsubsection{human}
\begin{itemize}
  \item Data exchange between SD2 and S/A VM
  \item Driving logic (brake and accel if needed to maintain given speed)
\end{itemize}
\subsubsection{usr}
\begin{itemize}
  \item Now a simple parked car (accel=0, brake=1, steer=0)
  \item Should be moved to own bot
\end{itemize}
\subsection{Data exchange with S/A VM}
\begin{itemize}
  \item Protocol (protobuf, 4 byte message length header + message, tcp socket)
  \item Problem Nagle's algorithm $\rightarrow$ disable it via TCP\_NODELAY
\end{itemize}
\section{SimCoupler}
\begin{itemize}
  \item Why did we drop SimCoupler
  \item Where do we need to make changes to integrate it
  \item Shared protobuf module problem and possible solution
\end{itemize}
\newpage
\section{S/A VM}
\subsection{Data exchange with speedDreams 2}
  \subsubsection{Protobuf}
Google Protobuf is a protocol for network data exchange.
The newest version can be found \href{https://github.com/google/protobuf}{here}.
To exchange data, protobuf files habe to be created beforehand.
One of the protobuf files designed during this pratical course looks like this: 
  \begin{figure}[!h]
  \begin{minipage}{0.5\textwidth}
  \centering
    \begin{minted}[fontsize=\tiny]{protobuf}
	syntax = "proto3";
	package protobuf;
	
	import "sensor.proto";
	import "wheel.proto";
	import "specification.proto";
	
	message State {
	  repeated Sensor sensor = 1;
	  repeated Wheel wheel = 2;
	  Specification specification = 3;
	  float steer = 4;
	  float brakeCmd = 5;
	  float accelCmd = 6;
	}
    \end{minted}
  \end{minipage}
  \begin{minipage}{0.5\textwidth}
    \begin{itemize}
\item The version of the syntax is defined.
\item All packages and imports are declared.
\item The message is constructed. Attributes can be other Protobuf messages, simple datatypes, like int or float, or a list "repeated" of any attributes named.
    \end{itemize}
  \end{minipage}
    \caption{\tiny state.proto}
  \end{figure}
  \subsubsection{TCP/IP}
Before any network interaction can take place, the network has to be initialized. Therefore the library lwip is usually needed. But since the mosquitto library already initializes lwip, another initialization within the components code caused lwip and moquitto to freeze.\newline
Furthermore dhcp and manuall ip configuration have to be seperated in the initialization, since dhcp ip assignement takes up to 10 seconds, however manuall ip assignement takes place instantly.
The configuration takes place in the run file of the component.\newline
\begin{figure}[!h]
  \centering
    \begin{minted}[fontsize=\tiny]{cpp}
<network dhcp="yes" ip-address="192.168.178.3" subnet-mask="255.255.255.0" default-gateway="192.168.178.1" />
<speedDreams ip-address="10.200.32.15" port="9002" />
<mosquitto ip-address="10.200.32.15" port="1883" />
    \end{minted}
    \caption{\tiny S/A VM run file}
  \end{figure}
If dhcp is set to "yes" any following configuration is ignored.\newline
If dhcp is set to "no" there is our address followed by the subnetmask and the default gateway of the VDE adapter or the connected ethernet network.\newline
SpeedDreams2's address and port as well as mosquitto server's address and port can be configured.
  \subsection{Our protocol} \label{ourprotocol}
To be able to change data, some preparation needs to be done beforehand. Since it is not usefull to send data without knowledge over its size, some kind of a protocol around the protobuf data exchange had to be designed. Therefore it was decided to send a 4 byte long value which contains the size of the following protobuf state, is sent to start the actual exchange. Any other messages are dropped.
  \subsubsection{Deserialization}
Once a message of given size was received it needs to be deserialized. Fortunately the method "ParseFromArray" does the job. Afterwards all received information is stored within a protobuf state. This object has automatically generated getter and setter methods, which makes it easy to access the actual data. Finally the multiplexing of the S/A VM takes place. Any data within the state object is published via mosquitto within the topic "state".
  \subsubsection{serialize}
Right after the deserialization of the state message, a new message called control is created. Any information the S/A VM got from the ECU is now put into this protobuf object. Afterwards the object is serialized using SerializeToString. As mentioned in \ref{ourprotocol} before the actuall protobuf file can be sent over ethernet, its size in a seperate 4 byte message, initializes the data exchange. But finally the serialized protobuf message is sent back to speedDreams2 which can now continue with the next simualtion step.
  \subsubsection{Nagle's algorithm}
The goal of the \href{https://www.lifewire.com/nagle-algorithm-for-tcp-network-communication-817932}{nagle's algorithm} is to minimize the number of packets sent by the network stack. Therefore it piles up small messages. Unfortunately this approach brakes completely with the real time requirement of the S/A VM. Therefore this algorithm had to be disabled by activating the "TCP\_NODELAY" option of the lwip library.
  \subsubsection{Do not wait for answer of ECU}
To keep latency as low as possible the S/A VM answeres immediately after it got a state message from speedDreams2. No matter whether the S/A VM already got an update for the next step of the ECU. If the S/A VM waited for the ECU's mosquitto messages, there would be so much latency that speedDreams had to run in 1/8 realtime. For the sake of realtime the S/A VM does not care if it misses a message from the ECU. This is not a problem since the ECU does not care about the past but only about the next step. Therefore the ECU is able to correct missing instructions in the next step.
\subsection{Data exchange with ECU}
  \subsubsection{MQTT/mosquitto/publish subscribe}
  \subsubsection{callbacks}
  \subsubsection{lwip mosquitto foo}
\section{ECU}
\section{Misc}
\begin{itemize}
  \item Porting of the mosquitto library % FIXME do we really want to add the mosquitto port in our documentation?
\end{itemize}

\end{document}
