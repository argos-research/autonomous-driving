\documentclass[paper=a4, fontsize=11pt]{scrreprt}

\usepackage[utf8]{inputenc}
\usepackage[ngerman,english]{babel}
\usepackage{gensymb}

\usepackage[yyyymmdd]{datetime}
\renewcommand{\dateseparator}{-}

\usepackage{hyperref}

\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{decorations.pathreplacing}

\usepackage{natbib}
\bibliographystyle{plain}

\usepackage{minted}
\usemintedstyle{rainbow_dash}

\usepackage{mathtools}

\title{Autonomous Parking Scenario}
\subtitle{Linux und L4-Mikrokern, SS 2017}
\author{Alexander Reisner \href{mailto:alexander.reisner@tum.de}{\texttt{alexander.reisner@tum.de}} \and
Alexander Weidinger \href{mailto:alexander.weidinger@tum.de}{\texttt{alexander.weidinger@tum.de}} \and
David Werner \href{mailto:david.werner@tum.de}{\texttt{david.werner@tum.de}}}
\date{\today}

\begin{document}

% title page
\maketitle
\newpage

% toc
\tableofcontents
\newpage

% introduction
\chapter{Introduction}
This document is the final report, written by the students Alexander Reisner,
Alexander Weidinger and David Werner, for the 'Linux und L4-Mikrokern' SS 2017 practical course at the Technical University of Munich.

\begin{itemize}
  \item Task description
  \item Overview diagram
  \item Dataflow diagram (sequence diagram?)
\end{itemize}

% changes to speed dreams 2
% -------------------------
\chapter{Speed Dreams 2}
Speed Dreams 2 (SD2) is a fork of the open racing car simulator (TORCS)
and was used as our main car simulation.
Since the simulator was merely intended as a racing simulator,
it only provides limited functionality in case of virtual sensors.
Fortunately it can be easily expanded since the project itself is open source
and more or less sufficiently documented for such tasks.
Additionally there is a mailing list and a online forum,
where other people are willing to help in case of questions.

For our autonomous parking use case we needed to make some changes to SD2,
which affect the proximity sensor itself, the starting position of the cars
and finally changes to the driving bots.

% proximity sensor
\section{Proximity Sensor}
Since SD2 itself doesn't provide virtual proximity sensors,
we either need to implement one ourselves or we make use of related projects.
Luckily the 'Simulated Car Racing Championship 2015' (SCRC) \cite{scrc2015} extends the TORCS simulator by two new sensors,
one being an 'opponent' sensor, which measures the distance between the driving car and an opponent.
Furthermore there is a 'focus' sensor, which measures the distance between the car and the track edge.

% reference implementation by the SCRC
\subsection{SCRC Implementation}
The problem with the given implementation is,
that the 'opponent' sensor just measures the distance between two cars given the middle point of both cars.
This means, that given two cars with a width of 4 meters,
if they are both touching while standing directly next to each other,
the sensor would still report a distance of 4 meters between them.
This distance given by this sensor can be used to get a basic idea on where other cars are
and how far they are distant to itself but are completely useless for our parking scenario.

% our own implementation
\subsection{Our Implementation}
We simplify the virtual proximity sensor to a mere straight line,
with a given angle and position relative to the center of the car.

The opponent car can be cut down to four straight lines,
acting as the four sides of a car.

In order to now calculate the shortest distance to an opponent car,
the algorithm takes the following steps:

\begin{enumerate}
  \item Iterate over all opponent cars.
  \begin{enumerate}
    \item Calculate intersections between the straight line from the laser
    and the four straight lines from the sides of the opponent car.
    \item Iterate over all intersections.
    \begin{enumerate}
      \item Test if point of intersection is within the domain of the respective side of the car.
      \item\label{infront} Check if the intersection is 'in front' of the sensor.
    \end{enumerate}
    \item Save the potentially shortest distance to an opponent, if not already a shorter distance was found.
  \end{enumerate}
  \item Accept the shortest distance as the current value of the proximity sensor.
\end{enumerate}

Step \ref{infront} is necessary, since we are working with straight lines
and not vectors. Otherwise it could happen,
that objects on the other side of the car have to shortest distance to the sensor
and therefore are accepted as the current value of the sensor.
A mockup of our idea can be seen in figure \ref{aw_mockup}.
The distance $d_2$ would be the correct value for the proximity sensor,
indicated by the dashed blue line.

\begin{figure}[ht]\label{aw_mockup}
  \begin{center}
    \begin{tikzpicture}[scale=1]
      % car 1
      \draw (0,0) -- (2,0) -- (2,3) -- (0,3) -- (0,0);
      \fill (1, 1.5) circle [radius=0.05];
      % car 2
      \draw (3,1) -- (5,1) -- (5,4) -- (3,4) -- (3,1);
      \fill (4, 2.5) circle [radius=0.05];
      % sensor
      \draw[blue, dashed] (2, 1.5) -- +(0 : 4); % line
      \fill[blue] (2, 1.5) circle [radius=0.05]; % starting point
      % intersections
      \draw[blue] (3, 1.5) circle [radius=0.1];
      \draw[blue]  (5, 1.5) circle [radius=0.1];
      % distance bracket
      \draw[decoration={brace,mirror,raise=5pt},decorate] (2, 1.5) -- (3, 1.5) node[black,midway,yshift=-0.5cm] {\footnotesize $d_2$};
    \end{tikzpicture}
    \caption{Mockup of our (laser) proximity sensor implementation}
  \end{center}
\end{figure}

\subsubsection{Implementation}

\begin{listing}[ht]\label{aw_sensor_position}
  \inputminted[firstline=91,linenos=true,lastline=96,gobble=2]{c++}{../../../simulators/speed-dreams/src/libs/sensors/obstacleSensors.cpp}
  \caption{\texttt{src/libs/sensors/obstacleSensors.cpp}}
\end{listing}

\begin{equation}
  m_1 * x + t_1 = m_2 * x + t_2 \equiv x = (t_2 - t_1) / (m_1 - m2)
\end{equation}


\begin{itemize}
  \item Show important parts of the code and explain
  \item Explain trick with obstacle behind sensor (reference point)
\end{itemize}

\subsubsection{Usage}
As an example on how to use the newly created obstacleSensors library,
one can take a look at the human driver in listing \ref{aw_sensors}.

\begin{listing}[ht]\label{aw_sensors}
  \inputminted[firstline=245,linenos=true,lastline=256]{c++}{../../../simulators/speed-dreams/src/drivers/human/human.cpp}
  \caption{\texttt{src/drivers/human/human.cpp}}
\end{listing}

The code adds three sensors, one in the front with 0\degree{} angle
and one in the back with an angle of 180\degree{}.
Both sensors are moved relative to the center point of the car,
according to the schematics in the comment.
The last sensor (second sensor in the example code) is directed in an 90\degree{} angle
and moved to the right side of the rear axle.
As a side note, all three sensors have a maximum range of 20 meters,
which can be changed with the last parameter.

\subsubsection{Evaluation}
\begin{itemize}
  \item Show some example pictures and sensor values
\end{itemize}

\subsubsection{Open points}
Our main focus was getting the overall setup running,
therefore a few open points are still left open
and can be fixed in future versions.

If one takes a look into the \texttt{sensors\_update} function,
it is obvious that the sensor is moved to the correct position in each update.
To optimize the code, this part could be easily moved into the constructor of each sensor
and therefore improve the performance of this update function.

The whole implementation is based on straight lines
and therefore needs some hacks to deal with directions.
To overcome this issue it would make sense to change the implementation to vectors.
This could also fix some potential glitches with wrong distance values,
which can occur on collisions.
Lastly the implementation only represents a laser proximity sensor
in contrast to the implementation by the SCRC,
which can detect or more precisely assigns opponents in angle ranges.

\section{Starting Grid}
In order to test the successful execution of our parking algorithm,
we need to be able to get reproducible results in every run.

\subsection{Idea}
As we are not able to create some kind of run configuration files for SD2
and an implementation of such a system would take a lot of work,
we made use of the starting grid in the initialization phase of a race.

\subsection{Implementation}
Normally the \textit{*.xml} file of a track specifies the number of rows,
the cars are placed in at the start line.
The distance between the cars is then automatically adjusted and calculated,
taking in mind the overall width of the track, the course of the road, etc.

For the purpose of the parking scenario we hard coded the row value to one:
\begin{listing}[ht]
  \inputminted[firstline=309,linenos=true,lastline=311]{c++}{../../../simulators/speed-dreams/src/modules/racing/standardgame/raceinit.cpp}
  \caption{\texttt{src/modules/racing/standardgame/raceinit.cpp}}
\end{listing}

We also made sure to place each car 8 meters further away from the start line by choosing a fix value in the code.
Additionally to get the second and last car to either be 3 meters to the left or right,
we adapted the position change to the right accordingly in the code:
\begin{listing}[ht]
  \inputminted[firstline=316,linenos=true,lastline=327]{c++}{../../../simulators/speed-dreams/src/modules/racing/standardgame/raceinit.cpp}
  \caption{\texttt{src/modules/racing/standardgame/raceinit.cpp}}
\end{listing}

In order to ensure, that the changes don't interfere with future development,
the changes only get used, if the code is compiled with the \texttt{PARKING} option enabled.

\section{Driving bots}
\begin{itemize}
  \item We still want to be able to drive ourselves $\rightarrow$ reuse human driver
  \item We need a parked car bot
\end{itemize}

\subsubsection{human}
\begin{itemize}
  \item Data exchange between SD2 and S/A VM
  \item Driving logic (brake and accel if needed to maintain given speed)
\end{itemize}
\subsubsection{usr}
\begin{itemize}
  \item Now a simple parked car (accel=0, brake=1, steer=0)
  \item Should be moved to own bot
\end{itemize}
\subsection{Data exchange with S/A VM}
\begin{itemize}
  \item Protocol (protobuf, 4 byte message length header + message, tcp socket)
  \item Problem Nagle's algorithm $\rightarrow$ disable it via TCP\_NODELAY
\end{itemize}
\section{SimCoupler}
\begin{itemize}
  \item Why did we drop SimCoupler
  \item Where do we need to make changes to integrate it
  \item Shared protobuf module problem and possible solution
\end{itemize}
\section{S/A VM}
\section{ECU}
\section{Misc}
\begin{itemize}
  \item Porting of the mosquitto library % FIXME do we really want to add the mosquitto port in our documentation?
\end{itemize}

\bibliography{final-report_group3}

\end{document}
