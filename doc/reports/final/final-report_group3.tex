\documentclass[paper=a4, fontsize=11pt]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage[ngerman,english]{babel}
\usepackage{hyperref}
\usepackage{wrapfig}
\usepackage{minted}
\usepackage{multicol}
\usepackage{color}
\usepackage{pifont}
\usepackage{tikz}
\usepackage{amsmath}

\title{Autonomous Parking Scenario}
\author{Alexander Reisner \href{mailto:alexander.reisner@tum.de}{\texttt{alexander.reisner@tum.de}} \and
Alexander Weidinger \href{mailto:alexander.weidinger@tum.de}{\texttt{alexander.weidinger@tum.de}} \and
David Werner \href{mailto:david.werner@tum.de}{\texttt{david.werner@tum.de}}}
\date{\today}

\begin{document}

% title page
\maketitle
\newpage

% toc
\tableofcontents
\newpage

\section{General}
\begin{itemize}
  \item Task description
  \item Overview diagram
  \item Dataflow diagram (sequence diagram?)
\end{itemize}
\section{SpeedDreams 2}
\begin{itemize}
  \item What is SpeedDreams 2?
  \item Why do we need SpeedDreams 2?
  \item What changes do we need to make?
\end{itemize}
\subsection{Proximity Sensor}
\begin{itemize}
  \item Related work (Sensor by the Simulated Car Racing Championship, ...)
  \item Idea and approach
  \item Implementation details and problems (+ solutions)
\end{itemize}
\subsection{Starting Grid}
\begin{itemize}
  \item We need it to get reproducible results each run
  \item Idea and approach
  \item Implementation details
\end{itemize}
\subsection{Driving bots}
\subsubsection{human}
\begin{itemize}
  \item Data exchange between SD2 and S/A VM
  \item Driving logic (brake and accel if needed to maintain given speed)
\end{itemize}
\subsubsection{usr}
\begin{itemize}
  \item Now a simple parked car (accel=0, brake=1, steer=0)
  \item Should be moved to own bot
\end{itemize}
\subsection{Data exchange with S/A VM}
\begin{itemize}
  \item Protocol (protobuf, 4 byte message length header + message, tcp socket)
  \item Problem Nagle's algorithm $\rightarrow$ disable it via TCP\_NODELAY
\end{itemize}
\section{SimCoupler}
\begin{itemize}
  \item Why did we drop SimCoupler
  \item Where do we need to make changes to integrate it
  \item Shared protobuf module problem and possible solution
\end{itemize}
\newpage
\section{S/A VM}
\subsection{Data exchange with speedDreams 2}
  \subsubsection{Protobuf}
Google Protobuf is a protocol for network data exchange.
The newest version can be found \href{https://github.com/google/protobuf}{here}.
To exchange data, protobuf files habe to be created beforehand.
One of the protobuf files designed during this pratical course looks like this: 
  \begin{figure}[!h]
  \begin{minipage}{0.5\textwidth}
  \centering
    \begin{minted}[fontsize=\tiny]{protobuf}
	syntax = "proto3";
	package protobuf;
	
	import "sensor.proto";
	import "wheel.proto";
	import "specification.proto";
	
	message State {
	  repeated Sensor sensor = 1;
	  repeated Wheel wheel = 2;
	  Specification specification = 3;
	  float steer = 4;
	  float brakeCmd = 5;
	  float accelCmd = 6;
	}
    \end{minted}
  \end{minipage}
  \begin{minipage}{0.5\textwidth}
    \begin{itemize}
\item The version of the syntax is defined.
\item All packages and imports are declared.
\item The message is constructed. Attributes can be other Protobuf messages, simple datatypes, like int or float, or a list "repeated" of any attributes named.
    \end{itemize}
  \end{minipage}
    \caption{\tiny state.proto}
  \end{figure}
  \subsubsection{TCP/IP} \label{tcpip}
Before any network interaction can take place, the network has to be initialized. Therefore the library lwip is usually needed. But since the mosquitto library already initializes lwip, another initialization within the components code caused lwip and moquitto to freeze.\newline
Furthermore dhcp and manuall ip configuration have to be seperated in the initialization, since dhcp ip assignement takes up to 10 seconds, however manuall ip assignement takes place instantly.
The configuration takes place in the run file of the component.\newline
\begin{figure}[!h]
  \centering
    \begin{minted}[fontsize=\tiny]{cpp}
<network dhcp="yes" ip-address="192.168.178.3" subnet-mask="255.255.255.0" default-gateway="192.168.178.1" />
<speedDreams ip-address="10.200.32.15" port="9002" />
<mosquitto ip-address="10.200.32.15" port="1883" />
    \end{minted}
    \caption{\tiny S/A VM run file}
  \end{figure}
If dhcp is set to "yes" any following configuration is ignored.\newline
If dhcp is set to "no" there is our address followed by the subnetmask and the default gateway of the VDE adapter or the connected ethernet network.\newline
SpeedDreams2's address and port as well as mosquitto server's address and port can be configured.
  \subsection{Our protocol} \label{ourprotocol}
To be able to change data, some preparation needs to be done beforehand. Since it is not usefull to send data without knowledge over its size, some kind of a protocol around the protobuf data exchange had to be designed. Therefore it was decided to send a 4 byte long value which contains the size of the following protobuf state, is sent to start the actual exchange. Any other messages are dropped.
  \subsubsection{Deserialization}
Once a message of given size was received it needs to be deserialized. Fortunately the method "ParseFromArray" does the job. Afterwards all received information is stored within a protobuf state. This object has automatically generated getter and setter methods, which makes it easy to access the actual data. Finally the multiplexing of the S/A VM takes place. Any data within the state object is published via mosquitto within the topic "state".
  \subsubsection{Serialization}
Right after the deserialization of the state message, a new message called control is created. Any information the S/A VM got from the ECU is now put into this protobuf object. Afterwards the object is serialized using SerializeToString. As mentioned in \ref{ourprotocol} before the actuall protobuf file can be sent over ethernet, its size in a seperate 4 byte message, initializes the data exchange. But finally the serialized protobuf message is sent back to speedDreams2 which can now continue with the next simualtion step.
  \subsubsection{Nagle's algorithm}
The goal of the \href{https://www.lifewire.com/nagle-algorithm-for-tcp-network-communication-817932}{nagle's algorithm} is to minimize the number of packets sent by the network stack. Therefore it piles up small messages. Unfortunately this approach brakes completely with the real time requirement of the S/A VM. Therefore this algorithm had to be disabled by activating the "TCP\_NODELAY" option of the lwip library.
  \subsubsection{Do not wait for answer of ECU}
To keep latency as low as possible the S/A VM answeres immediately after it got a state message from speedDreams2. No matter whether the S/A VM already got an update for the next step of the ECU. If the S/A VM waited for the ECU's mosquitto messages, there would be so much latency that speedDreams had to run in 1/8 realtime. For the sake of realtime the S/A VM does not care if it misses a message from the ECU. This is not a problem since the ECU does not care about the past but only about the next step. Therefore the ECU is able to correct missing instructions in the next step.
\newpage
\subsection{Data exchange with ECU}
  \subsubsection{MQTT}
\href{http://mqtt.org/}{MQTT} alias Message Queue Telemetry Transport is a protocol based on the publish-subscribe pattern.\newline
The publish-subscribe pattern describes a client server communication, where the server acts as a message broker and the clients subscribe and publish on topcis. The broker knows the subscriptions of clients and sends them a message if a message is published under a certain topic. Therefore network load can be taken from the clients and put to the server, since the clients only gets messages it is interessted in.
  \subsubsection{Subscribe}
The subscription is handled via "mosquittopp" which provides a method called "subscribe". This method needs the topic and the quality of message as input. Once a message on the given topic arrives at the server, the subscribed client is notified. This notification is handled by the callbacks \ref{callbacks} of mosquitto.
  \subsubsection{Publish}
The publishing is also handled via "mosquittopp" which provides another function called "publish". This method takes the topic, the message to be published and its size. The message finds its way to the server via the configuration done in the run file of the ECU. This configuration works the same way as described in TCP/IP \ref{tcpip} for the S/A VM.
  \subsubsection{Callbacks} \label{callbacks}
  \subsection{Starting the algorithm}
  \subsubsection{Car information}
Once the car length, the car width, the wheel radius and the maximum steering angle arrived at the ECU via pub/sub from the S/A VM, a new car information object is created. This needs to be done only once per ECU, since this static information does not change over time.
To be sure that the needed information arrived at the ECU boolean values were created that are set to true if a value arrived.
  \subsubsection{Compute next step}
The linker between pub/sub and the parking algorithm is the "receiveData" method. It is called once new values for the front, side and back laser, as well as the spin velocity, since the last timestamp, and the actual timestamp arrived. The topicality is handeld via boolean values, which are set to true, if a value arrived and set to false if a values was true and sent to the parking algorithm. Only full sets of data are used, for the sake of real time.
  \subsubsection{lwip mosquitto foo}
\section{ECU}
\section{Misc}
\begin{itemize}
  \item Porting of the mosquitto library % FIXME do we really want to add the mosquitto port in our documentation?
\end{itemize}

\end{document}
